use anyhow::Result;
use async_trait::async_trait;
use crate::app::jobs::{Job, JobContext};
use crate::app::notifications::channels::web_push_channel::WebPushChannel;
use serde::{Deserialize, Serialize};

/// Job for cleaning up inactive web push subscriptions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebPushCleanupJob {
    /// Number of days of inactivity before cleaning up subscriptions
    pub days_inactive: i32,
    /// Whether to validate subscriptions before cleanup
    pub validate_before_cleanup: bool,
}

impl WebPushCleanupJob {
    /// Create a new cleanup job
    pub fn new(days_inactive: i32, validate_before_cleanup: bool) -> Self {
        Self {
            days_inactive,
            validate_before_cleanup,
        }
    }

    /// Create a default cleanup job (30 days inactive, no validation)
    pub fn default_cleanup() -> Self {
        Self::new(30, false)
    }

    /// Create a thorough cleanup job (7 days inactive, with validation)
    pub fn thorough_cleanup() -> Self {
        Self::new(7, true)
    }
}

#[async_trait]
impl Job for WebPushCleanupJob {
    async fn handle(&self, _context: &JobContext) -> Result<()> {
        tracing::info!(
            "Starting web push cleanup job: {} days inactive, validate: {}",
            self.days_inactive,
            self.validate_before_cleanup
        );

        let mut total_cleaned = 0u64;

        // First pass: Clean up obviously inactive subscriptions
        match WebPushChannel::cleanup_inactive_subscriptions(self.days_inactive).await {
            Ok(cleaned) => {
                total_cleaned += cleaned;
                tracing::info!("Cleaned up {} inactive subscriptions", cleaned);
            }
            Err(e) => {
                tracing::error!("Failed to clean up inactive subscriptions: {}", e);
                return Err(e);
            }
        }

        // Second pass: Validate remaining subscriptions if requested
        if self.validate_before_cleanup {
            match self.validate_and_cleanup_invalid_subscriptions().await {
                Ok(validated_cleaned) => {
                    total_cleaned += validated_cleaned;
                    tracing::info!("Cleaned up {} invalid subscriptions after validation", validated_cleaned);
                }
                Err(e) => {
                    tracing::error!("Failed to validate and clean up subscriptions: {}", e);
                    // Don't return error here as the first cleanup was successful
                }
            }
        }

        tracing::info!(
            "Web push cleanup job completed. Total subscriptions cleaned: {}",
            total_cleaned
        );

        Ok(())
    }

    fn job_type(&self) -> &'static str {
        "WebPushCleanup"
    }

    fn max_attempts(&self) -> i32 {
        3
    }

    fn timeout_seconds(&self) -> Option<i32> {
        Some(1800) // 30 minutes timeout
    }
}

impl WebPushCleanupJob {
    /// Validate subscriptions and remove invalid ones
    async fn validate_and_cleanup_invalid_subscriptions(&self) -> Result<u64> {
        // Get all subscriptions (this would need to be implemented in WebPushChannel)
        // For now, we'll return 0 as this is a placeholder
        tracing::info!("Subscription validation cleanup not fully implemented yet");
        Ok(0)
    }
}

/// Job for monitoring web push metrics and health
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct WebPushMetricsJob {
    /// Whether to include detailed statistics
    pub include_detailed_stats: bool,
}

impl WebPushMetricsJob {
    pub fn new(include_detailed_stats: bool) -> Self {
        Self {
            include_detailed_stats,
        }
    }
}

#[async_trait]
impl Job for WebPushMetricsJob {
    async fn handle(&self, _context: &JobContext) -> Result<()> {
        tracing::info!("Starting web push metrics collection job");

        // Collect basic metrics
        let basic_metrics = self.collect_basic_metrics().await?;
        tracing::info!("Web push basic metrics: {:?}", basic_metrics);

        // Collect detailed metrics if requested
        if self.include_detailed_stats {
            let detailed_metrics = self.collect_detailed_metrics().await?;
            tracing::info!("Web push detailed metrics: {:?}", detailed_metrics);
        }

        Ok(())
    }

    fn job_type(&self) -> &'static str {
        "WebPushMetrics"
    }

    fn max_attempts(&self) -> i32 {
        2
    }

    fn timeout_seconds(&self) -> Option<i32> {
        Some(300) // 5 minutes timeout
    }
}

impl WebPushMetricsJob {
    async fn collect_basic_metrics(&self) -> Result<serde_json::Value> {
        // This would query the database for basic statistics
        // For now, return placeholder data
        Ok(serde_json::json!({
            "total_subscriptions": 0,
            "active_subscriptions": 0,
            "failed_subscriptions": 0,
            "timestamp": chrono::Utc::now().to_rfc3339()
        }))
    }

    async fn collect_detailed_metrics(&self) -> Result<serde_json::Value> {
        // This would query the database for detailed statistics
        // For now, return placeholder data
        Ok(serde_json::json!({
            "subscriptions_by_user_agent": {},
            "subscriptions_by_endpoint_domain": {},
            "success_rate_last_24h": 0.0,
            "average_response_time": 0.0,
            "timestamp": chrono::Utc::now().to_rfc3339()
        }))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cleanup_job_creation() {
        let job = WebPushCleanupJob::new(30, true);
        assert_eq!(job.days_inactive, 30);
        assert_eq!(job.validate_before_cleanup, true);
        assert_eq!(job.job_type(), "WebPushCleanup");
    }

    #[test]
    fn test_default_cleanup_job() {
        let job = WebPushCleanupJob::default_cleanup();
        assert_eq!(job.days_inactive, 30);
        assert_eq!(job.validate_before_cleanup, false);
    }

    #[test]
    fn test_thorough_cleanup_job() {
        let job = WebPushCleanupJob::thorough_cleanup();
        assert_eq!(job.days_inactive, 7);
        assert_eq!(job.validate_before_cleanup, true);
    }

    #[test]
    fn test_metrics_job_creation() {
        let job = WebPushMetricsJob::new(true);
        assert_eq!(job.include_detailed_stats, true);
        assert_eq!(job.job_type(), "WebPushMetrics");
    }
}